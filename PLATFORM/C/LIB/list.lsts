
type List<x> => Iterable<x>;
type List<x> => Collection<x>;

let $"[]"(tt: List<x>, idx: U64): x = (
   while idx > 0 {
      if not(tt.has-head()) {
         fail("index \{idx} is out of bounds for list of length \{tt.length()}");
      };
      tt = tail(tt);
   };
   head(tt)
);

##[DEPRECATED .iter().unique()]
let .unique(ls: List<x>): List<x> = (
   let rs = [] :: List<x>;
   for l in ls {
      if not(rs.contains(l)) {
         rs = cons(l, rs);
      }
   };
   rs
);

type ListIter<x> = ListIter { list: List<x> };
type ListIter<x> => Iterator<x>;

let .next(ls: ListIter<x>[]): Maybe<x> = (
   match open(ls.list) {
      [i.. rst] => (
         ls[0].list = rst;
         Some(i)
      );
      [] => (None :: Maybe<x>);
   };
);

# doesn't make a difference for List<x>
let .iter(li: List<x>): ListIter<x> = (
   li.unsafe-iter();
);

let .unsafe-iter(li: List<x>): ListIter<x> = (
   ListIter { li }
);

let .lookup(ls: List<Tuple<k,v>>, key: k, default: v): v = (
   let found = false;
   for Tuple{lkey=first, rval=second} in ls {
      if not(found) && key==lkey { default=rval; found=true; }
   };
   default;
);
let .lookup(ls: List<Tuple<k,v1,v2>>, key: k, default: Tuple<v1,v2>): Tuple<v1,v2> = (
   let found = false;
   for Tuple{lkey=first, val1=second, val2=third} in ls {
      if not(found) && key==lkey { default=Tuple{val1,val2}; found=true; }
   };
   default;
);

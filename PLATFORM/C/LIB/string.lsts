
let cmp(l: CString, r: CString): Ord = (
   let c = strcmp( (l as U8[]), (r as U8[]) );
   if c < 0_i32 { LessThan }
   else if c > 0_i32 { GreaterThan }
   else { Equal }
);

let print(io: IO::File, x: CString): Nil = (
   while head-string(x) != 0_u8 {
      fwrite(x as U8[], 1_u64, 1_u64, stdout());
      x = tail-string(x);
   };
);

let .is-digit(base: CString): U64 = (
   if non-zero(base) {
      let r = true;
      while head-string(base) != 0_u8 && r {
         r = 48_u8 <= head-string(base) && head-string(base) <= 57_u8;
         base = tail-string(base);
      };
      r
   } else false
);

let .substring(self: CString, begin: U64): CString = (
    ((((self as U8[]) as U64) + begin) as U8[]) as CString
);

let $"[]"(self: CString, idx: U64): U8 = (
    (self as U8[])[idx]
);

# TODO: move all generic collection functions somewhere else

let .find-first(list: t, elem: e): Maybe<U64> = (
   let found = false;

   let i = 0_u64;
   while i < list.length() {
      if list[i] == elem {
         found = true;
         break;
      } else {
         i = i + 1;
      };
   };

   if found {
      Some{i}
   } else {
      None
   }
);

let .find-last(list: t, elem: e): Maybe<U64> = (
   let found = false;
   let found_idx = 0_u64;

   let i = 0_u64;
   while i < list.length() {
      if list[i] == elem {
         found = true;
         found_idx = i;
      };
      i = i + 1;
   };

   if found {
      Some{found_idx}
   } else {
      None
   }
);
